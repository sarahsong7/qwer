//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
void SparcAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    268435458U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    536870922U,	// ADDCCri
    536870922U,	// ADDCCrr
    536870929U,	// ADDXri
    536870929U,	// ADDXrr
    536870935U,	// ADDri
    536870935U,	// ADDrr
    838860828U,	// ADJCALLSTACKDOWN
    838860847U,	// ADJCALLSTACKUP
    536870976U,	// ANDNri
    536870976U,	// ANDNrr
    536870982U,	// ANDri
    536870982U,	// ANDrr
    838860875U,	// BA
    1073741903U,	// BCOND
    838860881U,	// CALL
    603979863U,	// FABSD
    603979870U,	// FABSS
    536871013U,	// FADDD
    536871020U,	// FADDS
    1073741939U,	// FBCOND
    905969782U,	// FCMPD
    905969789U,	// FCMPS
    536871044U,	// FDIVD
    536871051U,	// FDIVS
    603979922U,	// FDTOI
    603979929U,	// FDTOS
    603979936U,	// FITOD
    603979943U,	// FITOS
    603979950U,	// FMOVD
    1476395189U,	// FMOVD_FCC
    1509949621U,	// FMOVD_ICC
    603979963U,	// FMOVS
    1476395202U,	// FMOVS_FCC
    1509949634U,	// FMOVS_ICC
    536871112U,	// FMULD
    536871119U,	// FMULS
    603979990U,	// FNEGD
    603979997U,	// FNEGS
    536871140U,	// FSMULD
    603980012U,	// FSQRTD
    603980020U,	// FSQRTS
    603980028U,	// FSTOD
    603980035U,	// FSTOI
    536871178U,	// FSUBD
    536871185U,	// FSUBS
    603980056U,	// FpABSD
    603980065U,	// FpMOVD
    603980074U,	// FpNEGD
    1610612817U,	// JMPLri
    1610612817U,	// JMPLrr
    1879048499U,	// LDDFri
    1879048499U,	// LDDFrr
    1879048505U,	// LDFri
    1879048505U,	// LDFrr
    1879048510U,	// LDSBri
    1879048510U,	// LDSBrr
    1879048517U,	// LDSHri
    1879048517U,	// LDSHrr
    1879048524U,	// LDUBri
    1879048524U,	// LDUBrr
    1879048531U,	// LDUHri
    1879048531U,	// LDUHrr
    1879048505U,	// LDri
    1879048505U,	// LDrr
    2147483671U,	// LEA_ADDri
    1476395354U,	// MOVFCCri
    1476395354U,	// MOVFCCrr
    1509949786U,	// MOVICCri
    1509949786U,	// MOVICCrr
    268435806U,	// NOP
    536871266U,	// ORNri
    536871266U,	// ORNrr
    536871271U,	// ORri
    536871271U,	// ORrr
    603980139U,	// POPCrr
    838861169U,	// RDY
    536871289U,	// RESTOREri
    536871289U,	// RESTORErr
    268435842U,	// RETL
    536871303U,	// SAVEri
    536871303U,	// SAVErr
    536871309U,	// SDIVri
    536871309U,	// SDIVrr
    268435859U,	// SELECT_CC_DFP_FCC
    268435887U,	// SELECT_CC_DFP_ICC
    268435915U,	// SELECT_CC_FP_FCC
    268435942U,	// SELECT_CC_FP_ICC
    268435969U,	// SELECT_CC_Int_FCC
    268435997U,	// SELECT_CC_Int_ICC
    603980345U,	// SETHIi
    536871488U,	// SLLri
    536871488U,	// SLLrr
    536871493U,	// SMULri
    536871493U,	// SMULrr
    536871499U,	// SRAri
    536871499U,	// SRArr
    536871504U,	// SRLri
    536871504U,	// SRLrr
    2415919701U,	// STBri
    2415919701U,	// STBrr
    2415919706U,	// STDFri
    2415919711U,	// STDFrr
    2415919717U,	// STFri
    2415919717U,	// STFrr
    2415919721U,	// STHri
    2415919721U,	// STHrr
    2415919717U,	// STri
    2415919717U,	// STrr
    536871534U,	// SUBCCri
    536871534U,	// SUBCCrr
    536871541U,	// SUBXCCrr
    536871549U,	// SUBXri
    536871549U,	// SUBXrr
    536871555U,	// SUBri
    536871555U,	// SUBrr
    536871560U,	// UDIVri
    536871560U,	// UDIVrr
    536871566U,	// UMULri
    536871566U,	// UMULrr
    922747540U,	// WRYri
    922747540U,	// WRYrr
    536871576U,	// XNORri
    536871576U,	// XNORrr
    536871582U,	// XORri
    536871582U,	// XORrr
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\000addcc \000addx \000add \000!ADJCALLSTACKDOWN \000!AD"
    "JCALLSTACKUP \000andn \000and \000ba \000b\000call \000fabsd \000fabss "
    "\000faddd \000fadds \000fb\000fcmpd \000fcmps \000fdivd \000fdivs \000f"
    "dtoi \000fdtos \000fitod \000fitos \000fmovd \000fmovd\000fmovs \000fmo"
    "vs\000fmuld \000fmuls \000fnegd \000fnegs \000fsmuld \000fsqrtd \000fsq"
    "rts \000fstod \000fstoi \000fsubd \000fsubs \000!FpABSD \000!FpMOVD \000"
    "!FpNEGD \000ldd [\000ld [\000ldsb [\000ldsh [\000ldub [\000lduh [\000mo"
    "v\000nop\000orn \000or \000popc \000rd %y, \000restore \000retl\000save"
    " \000sdiv \000; SELECT_CC_DFP_FCC PSEUDO!\000; SELECT_CC_DFP_ICC PSEUDO"
    "!\000; SELECT_CC_FP_FCC PSEUDO!\000; SELECT_CC_FP_ICC PSEUDO!\000; SELE"
    "CT_CC_Int_FCC PSEUDO!\000; SELECT_CC_Int_ICC PSEUDO!\000sethi \000sll \000"
    "smul \000sra \000srl \000stb \000std \000std  \000st \000sth \000subcc "
    "\000subxcc \000subx \000sub \000udiv \000umul \000wr \000xnor \000xor \000";

  processDebugLoc(MI->getDebugLoc());


#ifndef NO_ASM_WRITER_BOILERPLATE
  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return;
  }


#endif
  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023);


  // Fragment 0 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    return;
    break;
  case 1:
    // PHI, NOP, RETL, SELECT_CC_DFP_FCC, SELECT_CC_DFP_ICC, SELECT_CC_FP_FCC...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 1); 
    O << ", "; 
    break;
  case 3:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, FCMPD, FCMPS, RDY, WRYri, ...
    printOperand(MI, 0); 
    break;
  case 4:
    // BCOND, FBCOND
    printCCOperand(MI, 1); 
    O << ' '; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // FMOVD_FCC, FMOVD_ICC, FMOVS_FCC, FMOVS_ICC, MOVFCCri, MOVFCCrr, MOVICC...
    printCCOperand(MI, 3); 
    break;
  case 6:
    // JMPLri, JMPLrr
    printMemOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // LDDFri, LDDFrr, LDFri, LDFrr, LDSBri, LDSBrr, LDSHri, LDSHrr, LDUBri, ...
    printMemOperand(MI, 1); 
    O << "], "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // LEA_ADDri
    printMemOperand(MI, 1, "arith"); 
    O << ", "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // STBri, STBrr, STDFri, STDFrr, STFri, STFrr, STHri, STHrr, STri, STrr
    printOperand(MI, 2); 
    O << ", ["; 
    printMemOperand(MI, 0); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, RDY
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // FABSD, FABSS, FDTOI, FDTOS, FITOD, FITOS, FMOVD, FMOVS, FNEGD, FNEGS, ...
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // FCMPD, FCMPS, WRYri, WRYrr
    O << ", "; 
    printOperand(MI, 1); 
    break;
  case 4:
    // FMOVD_FCC, FMOVS_FCC, MOVFCCri, MOVFCCrr
    O << " %fcc0, "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // FMOVD_ICC, FMOVS_ICC, MOVICCri, MOVICCrr
    O << " %icc, "; 
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // WRYri, WRYrr
    O << ", %y"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
  } else {
    // FCMPD, FCMPS
    O << "\n\tnop"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
  }

  return;
}
