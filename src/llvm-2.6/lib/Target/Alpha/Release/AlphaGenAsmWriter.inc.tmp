//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
void AlphaAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    536870914U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1073741834U,	// ADDLi
    1073741834U,	// ADDLr
    1073741840U,	// ADDQi
    1073741840U,	// ADDQr
    1073741846U,	// ADDS
    1073741855U,	// ADDT
    1644167208U,	// ADJUSTSTACKDOWN
    1644167219U,	// ADJUSTSTACKUP
    1677721660U,	// ALTENT
    1073741886U,	// ANDi
    1073741886U,	// ANDr
    1077936195U,	// BEQ
    1077936200U,	// BGE
    1077936205U,	// BGT
    1073741906U,	// BICi
    1073741906U,	// BICr
    1073741911U,	// BISi
    1073741911U,	// BISr
    1077936220U,	// BLBC
    1077936226U,	// BLBS
    1077936232U,	// BLE
    1077936237U,	// BLT
    1077936242U,	// BNE
    1644167287U,	// BR
    1711276159U,	// BSR
    0U,	// CAS32
    0U,	// CAS64
    1073741961U,	// CMOVEQi
    1073741961U,	// CMOVEQr
    1073741969U,	// CMOVGEi
    1073741969U,	// CMOVGEr
    1073741977U,	// CMOVGTi
    1073741977U,	// CMOVGTr
    1073741985U,	// CMOVLBCi
    1073741985U,	// CMOVLBCr
    1073741994U,	// CMOVLBSi
    1073741994U,	// CMOVLBSr
    1073742003U,	// CMOVLEi
    1073742003U,	// CMOVLEr
    1073742011U,	// CMOVLTi
    1073742011U,	// CMOVLTr
    1073742019U,	// CMOVNEi
    1073742019U,	// CMOVNEr
    1073742027U,	// CMPBGE
    1073742027U,	// CMPBGEi
    1073742035U,	// CMPEQ
    1073742035U,	// CMPEQi
    1073742042U,	// CMPLE
    1073742042U,	// CMPLEi
    1073742049U,	// CMPLT
    1073742049U,	// CMPLTi
    1073742056U,	// CMPTEQ
    1073742067U,	// CMPTLE
    1073742078U,	// CMPTLT
    1073742089U,	// CMPTUN
    1073742100U,	// CMPULE
    1073742100U,	// CMPULEi
    1073742108U,	// CMPULT
    1073742108U,	// CMPULTi
    1744830756U,	// COND_BRANCH_F
    1778385188U,	// COND_BRANCH_I
    1073742142U,	// CPYSES
    1073742142U,	// CPYSESt
    1073742142U,	// CPYSET
    1073742149U,	// CPYSNS
    1073742149U,	// CPYSNSt
    1073742149U,	// CPYSNT
    1073742149U,	// CPYSNTs
    1073742156U,	// CPYSS
    1073742156U,	// CPYSSt
    1073742156U,	// CPYST
    1073742156U,	// CPYSTs
    1275068754U,	// CTLZ
    1275068760U,	// CTPOP
    1275068767U,	// CTTZ
    1275068773U,	// CVTQS
    1275068784U,	// CVTQT
    1275068795U,	// CVTST
    1275068804U,	// CVTTQ
    1275068815U,	// CVTTS
    1073742234U,	// DIVS
    1073742243U,	// DIVT
    1073742252U,	// EQVi
    1073742252U,	// EQVr
    1073742257U,	// EXTBL
    1073742264U,	// EXTLL
    1073742271U,	// EXTWL
    1077936582U,	// FBEQ
    1077936588U,	// FBGE
    1077936594U,	// FBGT
    1077936600U,	// FBLE
    1077936606U,	// FBLT
    1077936612U,	// FBNE
    2147484138U,	// FCMOVEQS
    2147484138U,	// FCMOVEQT
    2147484147U,	// FCMOVGES
    2147484147U,	// FCMOVGET
    2147484156U,	// FCMOVGTS
    2147484156U,	// FCMOVGTT
    2147484165U,	// FCMOVLES
    2147484165U,	// FCMOVLET
    2147484174U,	// FCMOVLTS
    2147484174U,	// FCMOVLTT
    2147484183U,	// FCMOVNES
    2147484183U,	// FCMOVNET
    1275068960U,	// FTOIS
    1275068967U,	// FTOIT
    1275068974U,	// ITOFS
    1275068981U,	// ITOFT
    1845494332U,	// JMP
    536871494U,	// JSR
    1879048790U,	// JSR_COROUTINE
    536871525U,	// JSRs
    0U,	// LAS32
    0U,	// LAS64
    1920991861U,	// LDA
    1920991866U,	// LDAH
    1946157690U,	// LDAHg
    1925186170U,	// LDAHr
    1946157685U,	// LDAg
    1929380469U,	// LDAr
    1920991872U,	// LDBU
    1929380480U,	// LDBUr
    1920991878U,	// LDL
    1920991883U,	// LDL_L
    1929380486U,	// LDLr
    1920991890U,	// LDQ
    1920991895U,	// LDQ_L
    1933574802U,	// LDQl
    1929380498U,	// LDQr
    1920991902U,	// LDS
    1929380510U,	// LDSr
    1920991907U,	// LDT
    1929380515U,	// LDTr
    1920991912U,	// LDWU
    1929380520U,	// LDWUr
    536871598U,	// MB
    1979712177U,	// MEMLABEL
    1073742523U,	// MULLi
    1073742523U,	// MULLr
    1073742529U,	// MULQi
    1073742529U,	// MULQr
    1073742535U,	// MULS
    1073742544U,	// MULT
    1073742553U,	// ORNOTi
    1073742553U,	// ORNOTr
    2013266656U,	// PCLABEL
    536871658U,	// RETDAG
    536871658U,	// RETDAGp
    1644167930U,	// RPCC
    1073742592U,	// S4ADDLi
    1073742592U,	// S4ADDLr
    1073742600U,	// S4ADDQi
    1073742600U,	// S4ADDQr
    1073742608U,	// S4SUBLi
    1073742608U,	// S4SUBLr
    1073742616U,	// S4SUBQi
    1073742616U,	// S4SUBQr
    1073742624U,	// S8ADDLi
    1073742624U,	// S8ADDLr
    1073742632U,	// S8ADDQi
    1073742632U,	// S8ADDQr
    1073742640U,	// S8SUBLi
    1073742640U,	// S8SUBLr
    1073742648U,	// S8SUBQi
    1073742648U,	// S8SUBQr
    1275069248U,	// SEXTB
    1275069255U,	// SEXTW
    1073742670U,	// SLi
    1073742670U,	// SLr
    1275069267U,	// SQRTS
    1275069277U,	// SQRTT
    1073742695U,	// SRAi
    1073742695U,	// SRAr
    1073742700U,	// SRLi
    1073742700U,	// SRLr
    1920992113U,	// STB
    1929380721U,	// STBr
    1920992118U,	// STL
    1098908539U,	// STL_C
    1929380726U,	// STLr
    1920992130U,	// STQ
    1098908551U,	// STQ_C
    1929380738U,	// STQr
    1920992142U,	// STS
    1929380750U,	// STSr
    1920992147U,	// STT
    1929380755U,	// STTr
    1920992152U,	// STW
    1929380760U,	// STWr
    1073742749U,	// SUBLi
    1073742749U,	// SUBLr
    1073742755U,	// SUBQi
    1073742755U,	// SUBQr
    1073742761U,	// SUBS
    1073742770U,	// SUBT
    0U,	// SWAP32
    0U,	// SWAP64
    1073742779U,	// UMULHi
    1073742779U,	// UMULHr
    536871874U,	// WMB
    536871878U,	// WTF
    1073742795U,	// XORi
    1073742795U,	// XORr
    1073742800U,	// ZAPNOTi
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\000addl \000addq \000adds/su \000addt/su \000; ADJDOWN "
    "\000; ADJUP \000$\000and \000beq \000bge \000bgt \000bic \000bis \000bl"
    "bc \000blbs \000ble \000blt \000bne \000br $31,\000bsr $26,$\000cmoveq "
    "\000cmovge \000cmovgt \000cmovlbc \000cmovlbs \000cmovle \000cmovlt \000"
    "cmovne \000cmpbge \000cmpeq \000cmple \000cmplt \000cmpteq/su \000cmptl"
    "e/su \000cmptlt/su \000cmptun/su \000cmpule \000cmpult \000:comment CON"
    "D_BRANCH imm:\000cpyse \000cpysn \000cpys \000CTLZ \000CTPOP \000CTTZ \000"
    "cvtqs/sui \000cvtqt/sui \000cvtst/s \000cvttq/svc \000cvtts/sui \000div"
    "s/su \000divt/su \000eqv \000EXTBL \000EXTLL \000EXTWL \000fbeq \000fbg"
    "e \000fbgt \000fble \000fblt \000fbne \000fcmoveq \000fcmovge \000fcmov"
    "gt \000fcmovle \000fcmovlt \000fcmovne \000ftois \000ftoit \000itofs \000"
    "itoft \000jmp $31,(\000jsr $26,($27),0\000jsr_coroutine \000jsr $23,($2"
    "7),0\000lda \000ldah \000ldbu \000ldl \000ldl_l \000ldq \000ldq_l \000l"
    "ds \000ldt \000ldwu \000mb\000LSMARKER$\000mull \000mulq \000muls/su \000"
    "mult/su \000ornot \000PCMARKER_\000ret $31,($26),1\000rpcc \000s4addl \000"
    "s4addq \000s4subl \000s4subq \000s8addl \000s8addq \000s8subl \000s8sub"
    "q \000sextb \000sextw \000sll \000sqrts/su \000sqrtt/su \000sra \000srl"
    " \000stb \000stl \000stl_l \000stq \000stq_l \000sts \000stt \000stw \000"
    "subl \000subq \000subs/su \000subt/su \000umulh \000wmb\000#wtf\000xor "
    "\000zapnot \000";

  processDebugLoc(MI->getDebugLoc());


#ifndef NO_ASM_WRITER_BOILERPLATE
  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return;
  }


#endif
  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023);


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    return;
    break;
  case 1:
    // PHI, JSR, JSRs, MB, RETDAG, RETDAGp, WMB, WTF
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BEQ, BGE, BGT, BIC...
    printOperand(MI, 1); 
    O << ','; 
    break;
  case 3:
    // ADJUSTSTACKDOWN, ADJUSTSTACKUP, ALTENT, BR, BSR, COND_BRANCH_F, COND_B...
    printOperand(MI, 0); 
    break;
  case 4:
    // FCMOVEQS, FCMOVEQT, FCMOVGES, FCMOVGET, FCMOVGTS, FCMOVGTT, FCMOVLES, ...
    printOperand(MI, 3); 
    O << ','; 
    printOperand(MI, 2); 
    O << ','; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 13 unique commands.
  switch ((Bits >> 25) & 15) {
  default:   // unreachable.
  case 0:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BEQ, BGE, BGT, BIC...
    printOperand(MI, 2); 
    break;
  case 1:
    // ADJUSTSTACKDOWN, ADJUSTSTACKUP, BR, RPCC
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ALTENT
    O << "..ng:\n"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // BSR
    O << "..ng"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // COND_BRANCH_F
    O << ", F8RC:"; 
    printOperand(MI, 1); 
    O << ", bb:"; 
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // COND_BRANCH_I
    O << ", GPRC:"; 
    printOperand(MI, 1); 
    O << ", bb:"; 
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // CTLZ, CTPOP, CTTZ, CVTQS, CVTQT, CVTST, CVTTQ, CVTTS, FTOIS, FTOIT, IT...
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // JMP
    O << "),0"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // JSR_COROUTINE
    O << ",("; 
    printOperand(MI, 1); 
    O << "),"; 
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // LDA, LDAH, LDAHr, LDAr, LDBU, LDBUr, LDL, LDL_L, LDLr, LDQ, LDQ_L, LDQ...
    O << ','; 
    printOperand(MI, 1); 
    O << '('; 
    printOperand(MI, 2); 
    break;
  case 10:
    // LDAHg, LDAg
    O << ",0("; 
    printOperand(MI, 2); 
    O << ")\t\t!gpdisp!"; 
    printOperand(MI, 3); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 11:
    // MEMLABEL
    O << '$'; 
    printOperand(MI, 1); 
    O << '$'; 
    printOperand(MI, 2); 
    O << '$'; 
    printOperand(MI, 3); 
    O << ':'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 12:
    // PCLABEL
    O << ":\n"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 3 bits for 7 unique commands.
  switch ((Bits >> 22) & 7) {
  default:   // unreachable.
  case 0:
    // ADDLi, ADDLr, ADDQi, ADDQr, ADDS, ADDT, ANDi, ANDr, BICi, BICr, BISi, ...
    O << ','; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // BEQ, BGE, BGT, BLBC, BLBS, BLE, BLT, BNE, FBEQ, FBGE, FBGT, FBLE, FBLT...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // LDA, LDAH, LDBU, LDL, LDL_L, LDQ, LDQ_L, LDS, LDT, LDWU, STB, STL, STQ...
    O << ')'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // LDAHr
    O << ")\t\t!gprelhigh"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // LDAr, LDBUr, LDLr, LDQr, LDSr, LDTr, LDWUr, STBr, STLr, STQr, STSr, ST...
    O << ")\t\t!gprellow"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // LDQl
    O << ")\t\t!literal"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // STL_C, STQ_C
    O << '('; 
    printOperand(MI, 3); 
    O << ')'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }

  return;
}
