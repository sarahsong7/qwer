//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
void MSP430AsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    268435458U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    536870922U,	// ADC16mi
    805306378U,	// ADC16mm
    536870922U,	// ADC16mr
    553648138U,	// ADC16ri
    822083594U,	// ADC16rm
    553648138U,	// ADC16rr
    536870930U,	// ADC8mi
    805306386U,	// ADC8mm
    536870930U,	// ADC8mr
    553648146U,	// ADC8ri
    822083602U,	// ADC8rm
    553648146U,	// ADC8rr
    536870938U,	// ADD16mi
    805306394U,	// ADD16mm
    536870938U,	// ADD16mr
    553648154U,	// ADD16ri
    822083610U,	// ADD16rm
    553648154U,	// ADD16rr
    536870945U,	// ADD8mi
    805306401U,	// ADD8mm
    536870945U,	// ADD8mr
    553648161U,	// ADD8ri
    822083617U,	// ADD8rm
    553648161U,	// ADD8rr
    268435496U,	// ADJCALLSTACKDOWN
    268435514U,	// ADJCALLSTACKUP
    536870986U,	// AND16mi
    805306442U,	// AND16mm
    536870986U,	// AND16mr
    553648202U,	// AND16ri
    822083658U,	// AND16rm
    553648202U,	// AND16rr
    536870993U,	// AND8mi
    805306449U,	// AND8mm
    536870993U,	// AND8mr
    553648209U,	// AND8ri
    822083665U,	// AND8rm
    553648209U,	// AND8rr
    1073741912U,	// CALLi
    1342177368U,	// CALLm
    1644167256U,	// CALLr
    1660944478U,	// CMP16im
    1665138782U,	// CMP16ir
    1946157150U,	// CMP16mi0
    1962934366U,	// CMP16mi1
    1979711582U,	// CMP16mi2
    1996488798U,	// CMP16mi4
    2013266014U,	// CMP16mi8
    1937768542U,	// CMP16mr
    1660944478U,	// CMP16rm
    1665138782U,	// CMP16rr
    1660944485U,	// CMP8im
    1665138789U,	// CMP8ir
    1946157157U,	// CMP8mi0
    1962934373U,	// CMP8mi1
    1979711589U,	// CMP8mi2
    1996488805U,	// CMP8mi4
    2013266021U,	// CMP8mi8
    1937768549U,	// CMP8mr
    1660944485U,	// CMP8rm
    1665138789U,	// CMP8rr
    2147483756U,	// JCC
    1644167278U,	// JMP
    536871027U,	// MOV16mi
    536871027U,	// MOV16mr
    2415919219U,	// MOV16ri
    2684354675U,	// MOV16rm
    2415919219U,	// MOV16rr
    536871034U,	// MOV8mi
    536871034U,	// MOV8mr
    2415919226U,	// MOV8ri
    2684354682U,	// MOV8rm
    2415919226U,	// MOV8rr
    2684354682U,	// MOVZX16rm8
    2415919226U,	// MOVZX16rr8
    268435585U,	// NOP
    536871045U,	// OR16mi
    805306501U,	// OR16mm
    536871045U,	// OR16mr
    553648261U,	// OR16ri
    822083717U,	// OR16rm
    553648261U,	// OR16rr
    536871052U,	// OR8mi
    805306508U,	// OR8mm
    536871052U,	// OR8mr
    553648268U,	// OR8ri
    822083724U,	// OR8rm
    553648268U,	// OR8rr
    1644167315U,	// POP16r
    1644167322U,	// PUSH16r
    268435618U,	// RET
    1644167334U,	// SAR16r1
    1644167341U,	// SAR16r1c
    1644167354U,	// SAR8r1
    1644167361U,	// SAR8r1c
    536871118U,	// SBC16mi
    805306574U,	// SBC16mm
    536871118U,	// SBC16mr
    553648334U,	// SBC16ri
    822083790U,	// SBC16rm
    553648334U,	// SBC16rr
    536871126U,	// SBC8mi
    805306582U,	// SBC8mm
    536871126U,	// SBC8mr
    553648342U,	// SBC8ri
    822083798U,	// SBC8rm
    553648342U,	// SBC8rr
    1644167390U,	// SEXT16r
    1644167395U,	// SHL16r1
    1644167402U,	// SHL8r1
    536871153U,	// SUB16mi
    805306609U,	// SUB16mm
    536871153U,	// SUB16mr
    553648369U,	// SUB16ri
    822083825U,	// SUB16rm
    553648369U,	// SUB16rr
    536871160U,	// SUB8mi
    805306616U,	// SUB8mm
    536871160U,	// SUB8mr
    553648376U,	// SUB8ri
    822083832U,	// SUB8rm
    553648376U,	// SUB8rr
    1644167423U,	// SWPB16r
    268435717U,	// Select16
    268435735U,	// Select8
    536871208U,	// XOR16mi
    805306664U,	// XOR16mm
    536871208U,	// XOR16mr
    553648424U,	// XOR16ri
    822083880U,	// XOR16rm
    553648424U,	// XOR16rr
    536871215U,	// XOR8mi
    805306671U,	// XOR8mm
    536871215U,	// XOR8mr
    553648431U,	// XOR8ri
    822083887U,	// XOR8rm
    553648431U,	// XOR8rr
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\000addc.w\t\000addc.b\t\000add.w\t\000add.b\t\000#ADJCA"
    "LLSTACKDOWN\000#ADJCALLSTACKUP\000and.w\t\000and.b\t\000call\t\000cmp.w"
    "\t\000cmp.b\t\000j\000jmp\t\000mov.w\t\000mov.b\t\000nop\000bis.w\t\000"
    "bis.b\t\000pop.w\t\000push.w\t\000ret\000rra.w\t\000clrc\n\trrc.w\t\000"
    "rra.b\t\000clrc\n\trrc.b\t\000subc.w\t\000subc.b\t\000sxt\t\000rla.w\t\000"
    "rla.b\t\000sub.w\t\000sub.b\t\000swpb\t\000# Select16 PSEUDO\000# Selec"
    "t8 PSEUDO\000xor.w\t\000xor.b\t\000";

  processDebugLoc(MI->getDebugLoc());


#ifndef NO_ASM_WRITER_BOILERPLATE
  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return;
  }


#endif
  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511);


  // Fragment 0 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    return;
    break;
  case 1:
    // PHI, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, Select16, Select8
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    printOperand(MI, 2); 
    O << ", "; 
    break;
  case 3:
    // ADC16mm, ADC16rm, ADC8mm, ADC8rm, ADD16mm, ADD16rm, ADD8mm, ADD8rm, AN...
    printSrcMemOperand(MI, 2); 
    O << ", "; 
    break;
  case 4:
    // CALLi
    printOperand(MI, 0, "call"); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // CALLm
    printSrcMemOperand(MI, 0, "mem"); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // CALLr, CMP16im, CMP16ir, CMP16rm, CMP16rr, CMP8im, CMP8ir, CMP8rm, CMP...
    printOperand(MI, 0); 
    break;
  case 7:
    // CMP16mi0, CMP16mi1, CMP16mi2, CMP16mi4, CMP16mi8, CMP16mr, CMP8mi0, CM...
    printSrcMemOperand(MI, 0); 
    break;
  case 8:
    // JCC
    printCCOperand(MI, 1); 
    O << ' '; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // MOV16ri, MOV16rr, MOV8ri, MOV8rr, MOVZX16rr8
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // MOV16rm, MOV8rm, MOVZX16rm8
    printSrcMemOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 9 unique commands.
  switch ((Bits >> 24) & 15) {
  default:   // unreachable.
  case 0:
    // ADC16mi, ADC16mm, ADC16mr, ADC8mi, ADC8mm, ADC8mr, ADD16mi, ADD16mm, A...
    printSrcMemOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // ADC16ri, ADC16rm, ADC16rr, ADC8ri, ADC8rm, ADC8rr, ADD16ri, ADD16rm, A...
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // CALLr, JMP, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8r1c, SEXT1...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // CMP16im, CMP16ir, CMP16mr, CMP16rm, CMP16rr, CMP8im, CMP8ir, CMP8mr, C...
    O << ", "; 
    break;
  case 4:
    // CMP16mi0, CMP8mi0
    O << ", #0"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // CMP16mi1, CMP8mi1
    O << ", #1"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // CMP16mi2, CMP8mi2
    O << ", #2"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // CMP16mi4, CMP8mi4
    O << ", #4"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // CMP16mi8, CMP8mi8
    O << ", #8"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 22) & 3) {
  default:   // unreachable.
  case 0:
    // CMP16im, CMP16rm, CMP8im, CMP8rm
    printSrcMemOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // CMP16ir, CMP16rr, CMP8ir, CMP8rr
    printOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // CMP16mr, CMP8mr
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }

  return;
}
