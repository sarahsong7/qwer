//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
void SystemZAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    268435458U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    536870922U,	// ADC32ri
    537919504U,	// ADC32rr
    536870933U,	// ADC64ri32
    537919516U,	// ADC64rr
    536870946U,	// ADD32ri
    538968103U,	// ADD32ri16
    540016684U,	// ADD32rm
    540016687U,	// ADD32rmy
    537919539U,	// ADD32rr
    538968119U,	// ADD64ri16
    536870973U,	// ADD64ri32
    540016707U,	// ADD64rm
    537919559U,	// ADD64rr
    537919564U,	// ADDE32rr
    537919570U,	// ADDE64rr
    268435545U,	// ADJCALLSTACKDOWN
    268435563U,	// ADJCALLSTACKUP
    537919611U,	// AND32ri
    537919617U,	// AND32rilh16
    537919623U,	// AND32rill16
    540016781U,	// AND32rm
    540016784U,	// AND32rmy
    537919636U,	// AND32rr
    537919640U,	// AND64rihh16
    537919646U,	// AND64rihi32
    537919652U,	// AND64rihl16
    537919617U,	// AND64rilh16
    537919623U,	// AND64rill16
    537919611U,	// AND64rilo32
    540016810U,	// AND64rm
    537919662U,	// AND64rr
    805306547U,	// BSWAP32mr
    541065401U,	// BSWAP32rm
    542113982U,	// BSWAP32rr
    805306564U,	// BSWAP64mr
    541065419U,	// BSWAP64rm
    542114001U,	// BSWAP64rr
    1073742040U,	// CALLi
    553648357U,	// CALLr
    543162609U,	// CMP32ri
    541065462U,	// CMP32rm
    541065465U,	// CMP32rmy
    542114045U,	// CMP32rr
    543162625U,	// CMP64ri32
    541065479U,	// CMP64rm
    542114059U,	// CMP64rr
    541065488U,	// CMPSX64rm32
    542114069U,	// CMPSX64rr32
    542114075U,	// FABS32rr
    542114082U,	// FABS64rr
    540016937U,	// FADD32rm
    537919790U,	// FADD32rr
    540016948U,	// FADD64rm
    537919801U,	// FADD64rr
    542114111U,	// FBCONVF64
    542114117U,	// FBCONVG64
    541065547U,	// FCMP32rm
    542114128U,	// FCMP32rr
    541065558U,	// FCMP64rm
    542114139U,	// FCMP64rr
    542114145U,	// FCONVFP32
    542114152U,	// FCONVFP32r64
    542114159U,	// FCONVFP64
    542114166U,	// FCONVFP64r32
    570425725U,	// FCONVGR32
    570425732U,	// FCONVGR32r64
    570425739U,	// FCONVGR64
    570425746U,	// FCONVGR64r32
    538182041U,	// FCOPYSIGN32
    538182041U,	// FCOPYSIGN64
    540017056U,	// FDIV32rm
    537919909U,	// FDIV32rr
    540017067U,	// FDIV64rm
    537919920U,	// FDIV64rr
    541065654U,	// FEXT32m64
    542114236U,	// FEXT32r64
    542114243U,	// FLOGR64
    544211402U,	// FMADD32rm
    545259984U,	// FMADD32rr
    544211415U,	// FMADD64rm
    545259997U,	// FMADD64rr
    805306852U,	// FMOV32mr
    805306857U,	// FMOV32mry
    541065711U,	// FMOV32rm
    541065715U,	// FMOV32rmy
    542114296U,	// FMOV32rr
    805306877U,	// FMOV64mr
    805306882U,	// FMOV64mry
    541065736U,	// FMOV64rm
    541065740U,	// FMOV64rmy
    542114321U,	// FMOV64rr
    544211478U,	// FMSUB32rm
    545260060U,	// FMSUB32rr
    544211491U,	// FMSUB64rm
    545260073U,	// FMSUB64rr
    540017200U,	// FMUL32rm
    537920054U,	// FMUL32rr
    540017213U,	// FMUL64rm
    537920066U,	// FMUL64rr
    542114376U,	// FNABS32rr
    542114383U,	// FNABS64rr
    542114390U,	// FNEG32rr
    542114397U,	// FNEG64rr
    542114404U,	// FROUND64r32
    541065835U,	// FSQRT32rm
    542114417U,	// FSQRT32rr
    541065848U,	// FSQRT64rm
    542114430U,	// FSQRT64rr
    540017285U,	// FSUB32rm
    537920138U,	// FSUB32rr
    540017296U,	// FSUB64rm
    537920149U,	// FSUB64rr
    553648795U,	// JE
    553648799U,	// JH
    553648803U,	// JHE
    553648808U,	// JL
    553648812U,	// JLE
    553648817U,	// JLH
    553648822U,	// JMP
    553648825U,	// JMPr
    553648829U,	// JNE
    553648834U,	// JNH
    553648839U,	// JNHE
    553648845U,	// JNL
    553648850U,	// JNLE
    553648856U,	// JNLH
    553648862U,	// JNO
    553648867U,	// JO
    541065959U,	// LA64r
    542114540U,	// LA64rm
    553648882U,	// LD_Fp032
    553648888U,	// LD_Fp064
    1392509694U,	// MOV128mr
    1610613525U,	// MOV128r0_even
    1955595035U,	// MOV128rm
    1890059057U,	// MOV128rr
    2231370568U,	// MOV16mi
    805307215U,	// MOV32m16r
    805307220U,	// MOV32m16ry
    805307226U,	// MOV32m8r
    805307231U,	// MOV32m8ry
    2248147813U,	// MOV32mi16
    805307243U,	// MOV32mr
    2415919983U,	// MOV32mrm
    805307253U,	// MOV32mry
    548406138U,	// MOV32ri16
    541066111U,	// MOV32rm
    542507906U,	// MOV32rmm
    541066119U,	// MOV32rmy
    542114699U,	// MOV32rr
    1459618703U,	// MOV64Pmr
    1476395941U,	// MOV64Pmry
    1610613626U,	// MOV64Pr0_even
    1958740924U,	// MOV64Prm
    1959789521U,	// MOV64Prmy
    805307215U,	// MOV64m16r
    805307220U,	// MOV64m16ry
    805307243U,	// MOV64m32r
    805307253U,	// MOV64m32ry
    805307226U,	// MOV64m8r
    805307231U,	// MOV64m8ry
    2248147943U,	// MOV64mi16
    805307374U,	// MOV64mr
    2415920115U,	// MOV64mrm
    548406037U,	// MOV64ri16
    543163385U,	// MOV64ri32
    542114815U,	// MOV64rihh16
    542114822U,	// MOV64rihi32
    542114829U,	// MOV64rihl16
    542114836U,	// MOV64rilh16
    542114843U,	// MOV64rill16
    542114850U,	// MOV64rilo32
    541066281U,	// MOV64rm
    542508077U,	// MOV64rmm
    542114866U,	// MOV64rr
    1890321463U,	// MOV64rrP
    2298479693U,	// MOV8mi
    2298479698U,	// MOV8miy
    541066328U,	// MOVSX32rm16
    541066332U,	// MOVSX32rm16y
    541066337U,	// MOVSX32rm8
    542114917U,	// MOVSX32rr16
    542114922U,	// MOVSX32rr8
    541066351U,	// MOVSX64rm16
    541066356U,	// MOVSX64rm32
    541066361U,	// MOVSX64rm8
    542114942U,	// MOVSX64rr16
    542114948U,	// MOVSX64rr32
    542114954U,	// MOVSX64rr8
    541066384U,	// MOVZX32rm16
    541066389U,	// MOVZX32rm8
    541066394U,	// MOVZX64rm16
    541066400U,	// MOVZX64rm32
    541066406U,	// MOVZX64rm8
    542114988U,	// MOVZX64rr32
    536872115U,	// MUL32ri
    538969273U,	// MUL32ri16
    540017854U,	// MUL32rm
    540017858U,	// MUL32rmy
    537920711U,	// MUL32rr
    538969292U,	// MUL64ri16
    536872146U,	// MUL64ri32
    540017881U,	// MUL64rm
    537920734U,	// MUL64rr
    537920740U,	// MUL64rrP
    537920744U,	// MULSX64rr32
    542115055U,	// NEG32rr
    542115060U,	// NEG64rr
    542115066U,	// NEG64rr32
    268436737U,	// NOP
    537920777U,	// OR32ri
    537920783U,	// OR32ri16
    537920789U,	// OR32ri16h
    540017947U,	// OR32rm
    540017950U,	// OR32rmy
    537920802U,	// OR32rr
    537920806U,	// OR64rihh16
    537920812U,	// OR64rihi32
    537920818U,	// OR64rihl16
    537920789U,	// OR64rilh16
    537920783U,	// OR64rill16
    537920777U,	// OR64rilo32
    540017976U,	// OR64rm
    537920828U,	// OR64rr
    268436801U,	// RET
    542508361U,	// ROTL32rri
    542508366U,	// ROTL64rri
    536872276U,	// SBC32ri
    537920859U,	// SBC32rr
    536872288U,	// SBC64ri32
    537920871U,	// SBC64rr
    540018029U,	// SDIVREM32m
    537920883U,	// SDIVREM32r
    540018042U,	// SDIVREM64m
    537920895U,	// SDIVREM64r
    2684355973U,	// SHL32rri
    542508426U,	// SHL64rri
    2684355984U,	// SRA32rri
    542508437U,	// SRA64rri
    2684355995U,	// SRL32rri
    542508448U,	// SRL64rri
    540018086U,	// SUB32rm
    540018089U,	// SUB32rmy
    537920941U,	// SUB32rr
    540018097U,	// SUB64rm
    537920949U,	// SUB64rr
    537920954U,	// SUBE32rr
    537920960U,	// SUBE64rr
    268436935U,	// Select32
    268436953U,	// Select64
    268436971U,	// SelectF32
    268436990U,	// SelectF64
    542115345U,	// UCMP32ri
    541066775U,	// UCMP32rm
    541066779U,	// UCMP32rmy
    542115360U,	// UCMP32rr
    542115365U,	// UCMP64ri32
    541066796U,	// UCMP64rm
    542115377U,	// UCMP64rr
    541066807U,	// UCMPZX64rm32
    542115389U,	// UCMPZX64rr32
    540018244U,	// UDIVREM32m
    537921096U,	// UDIVREM32r
    540018253U,	// UDIVREM64m
    537921106U,	// UDIVREM64r
    537921112U,	// UMUL128rrP
    537921118U,	// UMUL64rrP
    537921123U,	// XOR32ri
    540018281U,	// XOR32rm
    540018284U,	// XOR32rmy
    537921136U,	// XOR32rr
    540018292U,	// XOR64rm
    537921144U,	// XOR64rr
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\000alfi\t\000alr\t\000algfi\t\000algr\t\000afi\t\000ahi"
    "\t\000a\t\000ay\t\000ar\t\000aghi\t\000agfi\t\000ag\t\000agr\t\000alcr\t"
    "\000alcgr\t\000#ADJCALLSTACKDOWN\000#ADJCALLSTACKUP\000nilf\t\000nilh\t"
    "\000nill\t\000n\t\000ny\t\000nr\t\000nihh\t\000nihf\t\000nihl\t\000ng\t"
    "\000ngr\t\000strv\t\000lrv\t\000lrvr\t\000strvg\t\000lrvg\t\000lrvgr\t\000"
    "brasl\t%r14, \000basr\t%r14, \000cfi\t\000c\t\000cy\t\000cr\t\000cgfi\t"
    "\000cg\t\000cgr\t\000cgf\t\000cgfr\t\000lpebr\t\000lpdbr\t\000aeb\t\000"
    "aebr\t\000adb\t\000adbr\t\000ldgr\t\000lgdr\t\000ceb\t\000cebr\t\000cdb"
    "\t\000cdbr\t\000cefbr\t\000cegbr\t\000cdgbr\t\000cdfbr\t\000cfebr\t\000"
    "cfdbr\t\000cgdbr\t\000cgebr\t\000cpsdr\t\000deb\t\000debr\t\000ddb\t\000"
    "ddbr\t\000ldeb\t\000ldebr\t\000flogr\t\000maeb\t\000maebr\t\000madb\t\000"
    "madbr\t\000ste\t\000stey\t\000le\t\000ley\t\000ler\t\000std\t\000stdy\t"
    "\000ld\t\000ldy\t\000ldr\t\000mseb\t\000msebr\t\000msdb\t\000msdbr\t\000"
    "meeb\t\000meebr\t\000mdb\t\000mdbr\t\000lnebr\t\000lndbr\t\000lcebr\t\000"
    "lcdbr\t\000ledbr\t\000sqeb\t\000sqebr\t\000sqdb\t\000sqdbr\t\000seb\t\000"
    "sebr\t\000sdb\t\000sdbr\t\000je\t\000jh\t\000jhe\t\000jl\t\000jle\t\000"
    "jlh\t\000j\t\000br\t\000jne\t\000jnh\t\000jnhe\t\000jnl\t\000jnle\t\000"
    "jnlh\t\000jno\t\000jo\t\000lay\t\000larl\t\000lzer\t\000lzdr\t\000# MOV"
    "128 PSEUDO!\n\tstg\t\000lghi\t\000# MOV128 PSEUDO!\n\tlg\t\000# MOV128 "
    "PSEUDO!\n\tlgr\t\000mvhhi\t\000sth\t\000sthy\t\000stc\t\000stcy\t\000mv"
    "hi\t\000st\t\000stmy\t\000sty\t\000lhi\t\000l\t\000lmy\t\000ly\t\000lr\t"
    "\000# MOV64P PSEUDO!\n\tst\t\000# MOV64P PSEUDO!\n\tsty\t\000# MOV64P P"
    "SEUDO!\n\tl\t\000# MOV64P PSEUDO!\n\tly\t\000mvghi\t\000stg\t\000stmg\t"
    "\000lgfi\t\000llihh\t\000llihf\t\000llihl\t\000llilh\t\000llill\t\000ll"
    "ilf\t\000lg\t\000lmg\t\000lgr\t\000# MOV64P PSEUDO!\n\tlr\t\000mvi\t\000"
    "mviy\t\000lh\t\000lhy\t\000lb\t\000lhr\t\000lbr\t\000lgh\t\000lgf\t\000"
    "lgb\t\000lghr\t\000lgfr\t\000lgbr\t\000llh\t\000llc\t\000llgh\t\000llgf"
    "\t\000llgc\t\000llgfr\t\000msfi\t\000mhi\t\000ms\t\000msy\t\000msr\t\000"
    "mghi\t\000msgfi\t\000msg\t\000msgr\t\000mr\t\000msgfr\t\000lcr\t\000lcg"
    "r\t\000lcgfr\t\000# no-op\000oilf\t\000oill\t\000oilh\t\000o\t\000oy\t\000"
    "or\t\000oihh\t\000oihf\t\000oihl\t\000og\t\000ogr\t\000br\t%r14\000rll\t"
    "\000rllg\t\000sllfi\t\000slr\t\000slgfi\t\000slgr\t\000dsgf\t\000dsgfr\t"
    "\000dsg\t\000dsgr\t\000sll\t\000sllg\t\000sra\t\000srag\t\000srl\t\000s"
    "rlg\t\000s\t\000sy\t\000sr\t\000sg\t\000sgr\t\000slbr\t\000slbgr\t\000#"
    " Select32 PSEUDO\000# Select64 PSEUDO\000# SelectF32 PSEUDO\000# Select"
    "F64 PSEUDO\000clfi\t\000cl\t\000cly\t\000clr\t\000clgfi\t\000clg\t\000c"
    "lgr\t\000clgf\t\000clgfr\t\000dl\t\000dlr\t\000dlg\t\000dlgr\t\000mlgr\t"
    "\000mlr\t\000xilf\t\000x\t\000xy\t\000xr\t\000xg\t\000xgr\t\000";

  processDebugLoc(MI->getDebugLoc());


#ifndef NO_ASM_WRITER_BOILERPLATE
  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return;
  }


#endif
  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 2047);


  // Fragment 0 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    return;
    break;
  case 1:
    // PHI, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, Select32, Select64, S...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADC32ri, ADC32rr, ADC64ri32, ADC64rr, ADD32ri, ADD32ri16, ADD32rm, ADD...
    printOperand(MI, 0); 
    break;
  case 3:
    // BSWAP32mr, BSWAP64mr, FMOV32mr, FMOV32mry, FMOV64mr, FMOV64mry, MOV32m...
    printOperand(MI, 3); 
    O << ", "; 
    printRRIAddrOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // CALLi
    printPCRelImmOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // MOV128mr, MOV64Pmr, MOV64Pmry
    printOperand(MI, 3, "subreg_odd"); 
    O << ", "; 
    printRRIAddrOperand(MI, 0); 
    break;
  case 6:
    // MOV128r0_even, MOV64Pr0_even
    printOperand(MI, 0, "subreg_even"); 
    O << ", 0"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // MOV128rm, MOV128rr, MOV64Prm, MOV64Prmy, MOV64rrP
    printOperand(MI, 0, "subreg_odd"); 
    break;
  case 8:
    // MOV16mi, MOV32mi16, MOV64mi16, MOV8mi, MOV8miy
    printRIAddrOperand(MI, 0); 
    O << ", "; 
    break;
  case 9:
    // MOV32mrm, MOV64mrm
    printOperand(MI, 2); 
    O << ", "; 
    printOperand(MI, 3); 
    O << ", "; 
    printRIAddrOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // SHL32rri, SRA32rri, SRL32rri
    printOperand(MI, 1); 
    O << ", "; 
    printRIAddrOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 24) & 15) {
  default:   // unreachable.
  case 0:
    // ADC32ri, ADC32rr, ADC64ri32, ADC64rr, ADD32ri, ADD32ri16, ADD32rm, ADD...
    O << ", "; 
    break;
  case 1:
    // CALLr, JE, JH, JHE, JL, JLE, JLH, JMP, JMPr, JNE, JNH, JNHE, JNL, JNLE...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // FCONVGR32, FCONVGR32r64, FCONVGR64, FCONVGR64r32
    O << ", 5, "; 
    printOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // MOV128mr
    O << "\n\tstg\t"; 
    printOperand(MI, 3, "subreg_even"); 
    O << ", 8+"; 
    printRRIAddrOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // MOV128rm, MOV64Prm, MOV64Prmy
    O << ",  "; 
    printRRIAddrOperand(MI, 1); 
    break;
  case 5:
    // MOV16mi
    printS16ImmOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // MOV32mi16, MOV64mi16
    printS32ImmOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // MOV64Pmr
    O << "\n\tst\t"; 
    printOperand(MI, 3, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // MOV64Pmry
    O << "\n\tsty\t"; 
    printOperand(MI, 3, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // MOV8mi, MOV8miy
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 4 bits for 14 unique commands.
  switch ((Bits >> 20) & 15) {
  default:   // unreachable.
  case 0:
    // ADC32ri, ADC64ri32, ADD32ri, ADD64ri32, MUL32ri, MUL64ri32, SBC32ri, S...
    printS32ImmOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // ADC32rr, ADC64rr, ADD32rr, ADD64rr, ADDE32rr, ADDE64rr, AND32ri, AND32...
    printOperand(MI, 2); 
    break;
  case 2:
    // ADD32ri16, ADD64ri16, MUL32ri16, MUL64ri16
    printS16ImmOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // ADD32rm, ADD32rmy, ADD64rm, AND32rm, AND32rmy, AND64rm, FADD32rm, FADD...
    printRRIAddrOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // BSWAP32rm, BSWAP64rm, CMP32rm, CMP32rmy, CMP64rm, CMPSX64rm32, FCMP32r...
    printRRIAddrOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // BSWAP32rr, BSWAP64rr, CMP32rr, CMP64rr, CMPSX64rr32, FABS32rr, FABS64r...
    printOperand(MI, 1); 
    break;
  case 6:
    // CMP32ri, CMP64ri32, MOV64ri32
    printS32ImmOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // FMADD32rm, FMADD64rm, FMSUB32rm, FMSUB64rm
    printOperand(MI, 5); 
    O << ", "; 
    printRRIAddrOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // FMADD32rr, FMADD64rr, FMSUB32rr, FMSUB64rr
    printOperand(MI, 3); 
    O << ", "; 
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // MOV128rm
    O << "\n\tlg\t"; 
    printOperand(MI, 0, "subreg_even"); 
    O << ", 8+"; 
    printRRIAddrOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // MOV128rr, MOV64rrP
    printOperand(MI, 1, "subreg_odd"); 
    break;
  case 11:
    // MOV32ri16, MOV64ri16
    printS16ImmOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 12:
    // MOV64Prm
    O << "\n\tl\t"; 
    printOperand(MI, 0, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 13:
    // MOV64Prmy
    O << "\n\tly\t"; 
    printOperand(MI, 0, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 18) & 3) {
  default:   // unreachable.
  case 0:
    // ADC32rr, ADC64rr, ADD32rr, ADD64rr, ADDE32rr, ADDE64rr, AND32ri, AND32...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // FCOPYSIGN32, FCOPYSIGN64, MOV32rmm, MOV64rmm, ROTL32rri, ROTL64rri, SH...
    O << ", "; 
    break;
  case 2:
    // MOV128rr
    O << "\n\tlgr\t"; 
    printOperand(MI, 0, "subreg_even"); 
    O << ", "; 
    printOperand(MI, 1, "subreg_even"); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // MOV64rrP
    O << "\n\tlr\t"; 
    printOperand(MI, 0, "subreg_even"); 
    O << ", "; 
    printOperand(MI, 1, "subreg_even"); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 17) & 1) {
    // MOV32rmm, MOV64rmm, ROTL32rri, ROTL64rri, SHL64rri, SRA64rri, SRL64rri
    printRIAddrOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
  } else {
    // FCOPYSIGN32, FCOPYSIGN64
    printOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
  }

  return;
}
