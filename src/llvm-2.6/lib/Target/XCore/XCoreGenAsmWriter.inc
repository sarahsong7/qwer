//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
void XCoreAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    536870914U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1073741834U,	// ADD_2rus
    1073741834U,	// ADD_3r
    1644167169U,	// ADJCALLSTACKDOWN
    1677721601U,	// ADJCALLSTACKUP
    1090519055U,	// ANDNOT_2r
    1073741847U,	// AND_3r
    1073741852U,	// ASHR_l2rus
    1073741852U,	// ASHR_l3r
    1174405154U,	// BAU_1r
    1077936167U,	// BITREV_l2r
    1174405167U,	// BLA_1r
    1174405172U,	// BL_lu10
    1174405172U,	// BL_u10
    1077936184U,	// BRBF_lru6
    1077936184U,	// BRBF_ru6
    1077936188U,	// BRBT_lru6
    1077936188U,	// BRBT_ru6
    1174405184U,	// BRBU_lu6
    1174405184U,	// BRBU_u6
    1077936184U,	// BRFF_lru6
    1077936184U,	// BRFF_ru6
    1077936188U,	// BRFT_lru6
    1077936188U,	// BRFT_ru6
    1174405184U,	// BRFU_lu6
    1174405184U,	// BRFU_u6
    1077936196U,	// BYTEREV_l2r
    1077936205U,	// CLZ_l2r
    1073741906U,	// DIVS_l3r
    1073741912U,	// DIVU_l3r
    1174405214U,	// ECALLF_1r
    1174405222U,	// ECALLT_1r
    1174405230U,	// ENTSP_lu6
    1174405230U,	// ENTSP_u6
    1073741941U,	// EQ_2rus
    1073741941U,	// EQ_3r
    1174405241U,	// EXTSP_lu6
    1174405241U,	// EXTSP_u6
    536871040U,	// GETID_0R
    1074790540U,	// LADD_l5r
    1082130578U,	// LD16S_3r
    1082130585U,	// LD8U_3r
    1086324895U,	// LDA16B_l3r
    1082130591U,	// LDA16F_l3r
    1174405286U,	// LDAP_lu10
    1174405286U,	// LDAP_u10
    1086324913U,	// LDAWB_l2rus
    1086324913U,	// LDAWB_l3r
    2147483831U,	// LDAWCP_lu6
    2147483831U,	// LDAWCP_u6
    1207959729U,	// LDAWDP_lru6
    1207959729U,	// LDAWDP_ru6
    1778384897U,	// LDAWFI
    1082130609U,	// LDAWF_l2rus
    1082130609U,	// LDAWF_l3r
    1275068593U,	// LDAWSP_lru6
    1275068593U,	// LDAWSP_lru6_RRegs
    1275068593U,	// LDAWSP_ru6
    1275068593U,	// LDAWSP_ru6_RRegs
    1077936325U,	// LDC_lru6
    1077936325U,	// LDC_ru6
    1074790602U,	// LDIV_l5r
    1308623056U,	// LDWCP_lru6
    1308623056U,	// LDWCP_ru6
    1207959760U,	// LDWDP_lru6
    1207959760U,	// LDWDP_ru6
    1879048193U,	// LDWFI
    1275068624U,	// LDWSP_lru6
    1275068624U,	// LDWSP_ru6
    1082130640U,	// LDW_2rus
    1082130640U,	// LDW_3r
    1075314901U,	// LMUL_l6r
    1073742043U,	// LSS_3r
    1074790624U,	// LSUB_l5r
    1073742054U,	// LSU_3r
    1075839211U,	// MACCS_l4r
    1075839218U,	// MACCU_l4r
    1075314937U,	// MACC_l6r
    1077936383U,	// MKMSK_2r
    1077936383U,	// MKMSK_rus
    1073742086U,	// MUL_l3r
    1077936395U,	// NEG
    1077936400U,	// NOT
    1073742101U,	// OR_3r
    1073742105U,	// REMS_l3r
    1073742111U,	// REMU_l3r
    1174405413U,	// RETSP_lu6
    1174405413U,	// RETSP_u6
    1912602625U,	// SELECT_CC
    1174405420U,	// SETSP_1r
    1090519349U,	// SEXT_rus
    1073742139U,	// SHL_2rus
    1073742139U,	// SHL_3r
    1073742144U,	// SHR_2rus
    1073742144U,	// SHR_3r
    1082130757U,	// ST16_l3r
    1082130763U,	// ST8_l3r
    1207959888U,	// STWDP_lru6
    1207959888U,	// STWDP_ru6
    1946157057U,	// STWFI
    1275068752U,	// STWSP_lru6
    1275068752U,	// STWSP_ru6
    1082130768U,	// STW_2rus
    1082130768U,	// STW_3r
    1073742165U,	// SUB_2rus
    1073742165U,	// SUB_3r
    1073742170U,	// XOR_l3r
    1090519391U,	// ZEXT_rus
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\000add \000andnot \000and \000ashr \000bau \000bitrev \000"
    "bla \000bl \000bf \000bt \000bu \000byterev \000clz \000divs \000divu \000"
    "ecallf \000ecallt \000entsp \000eq \000extsp \000get r11, id\000ladd \000"
    "ld16s \000ld8u \000lda16 \000ldap r11, \000ldaw \000ldaw r11, cp[\000ld"
    "c \000ldiv \000ldw \000lmul \000lss \000lsub \000lsu \000maccs \000macc"
    "u \000macc \000mkmsk \000mul \000neg \000not \000or \000rems \000remu \000"
    "retsp \000set sp, \000sext \000shl \000shr \000st16 \000st8 \000stw \000"
    "sub \000xor \000zext \000";

  processDebugLoc(MI->getDebugLoc());


#ifndef NO_ASM_WRITER_BOILERPLATE
  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return;
  }


#endif
  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511);


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    return;
    break;
  case 1:
    // PHI, GETID_0R
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BAU_1r, BIT...
    printOperand(MI, 0); 
    break;
  case 3:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LDAWFI, LDWFI, SELECT_CC, STWFI
    PrintSpecial(MI, "comment"); 
    break;
  case 4:
    // LDAWCP_lu6, LDAWCP_u6
    printMemOperand(MI, 0); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 25) & 15) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN
    O << " ADJCALLSTACKDOWN "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << " ADJCALLSTACKUP "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // BAU_1r, BLA_1r, BL_lu10, BL_u10, BRBU_lu6, BRBU_u6, BRFU_lu6, BRFU_u6,...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp["; 
    printMemOperand(MI, 1); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // LDAWFI
    O << " LDAWFI "; 
    printOperand(MI, 0); 
    O << ", "; 
    printMemOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // LDAWSP_lru6, LDAWSP_lru6_RRegs, LDAWSP_ru6, LDAWSP_ru6_RRegs, LDWSP_lr...
    O << ", sp["; 
    printOperand(MI, 1); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp["; 
    printOperand(MI, 1); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // LDWFI
    O << " LDWFI "; 
    printOperand(MI, 0); 
    O << ", "; 
    printMemOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // SELECT_CC
    O << " SELECT_CC PSEUDO!"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // STWFI
    O << " STWFI "; 
    printOperand(MI, 0); 
    O << ", "; 
    printMemOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // ANDNOT_2r, SEXT_rus, ZEXT_rus
    printOperand(MI, 2); 
    EmitComments(*MI);

    O << "\n"; 
    return;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r, BRBF_lru6,...
    printOperand(MI, 1); 
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 22) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    O << ", "; 
    break;
  case 1:
    // BITREV_l2r, BRBF_lru6, BRBF_ru6, BRBT_lru6, BRBT_ru6, BRFF_lru6, BRFF_...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << '['; 
    printOperand(MI, 2); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-"; 
    printOperand(MI, 2); 
    O << ']'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 21) & 1) {
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 4); 
    O << ", "; 
    printOperand(MI, 5); 
    EmitComments(*MI);

    O << "\n"; 
    return;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2); 
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 20) & 1) {
    // LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r, MACC_l6r
    O << ", "; 
    printOperand(MI, 3); 
    O << ", "; 
    printOperand(MI, 4); 
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    EmitComments(*MI);

    O << "\n"; 
    return;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 19) & 1) {
    // LMUL_l6r, MACC_l6r
    O << ", "; 
    printOperand(MI, 5); 
    EmitComments(*MI);

    O << "\n"; 
    return;
  } else {
    // LADD_l5r, LDIV_l5r, LSUB_l5r
    EmitComments(*MI);

    O << "\n"; 
    return;
  }

  return;
}
