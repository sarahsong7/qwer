//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.  This method returns true if the
/// machine instruction was sufficiently described to print it, otherwise
/// it returns false.
void BlackfinAsmPrinter::printInstruction(const MachineInstr *MI) {
  static const unsigned OpInfo[] = {
    536870914U,	// PHI
    0U,	// INLINEASM
    0U,	// DBG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// DECLARE
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    536870922U,	// ABORT
    1073741825U,	// ADD
    1073741825U,	// ADD16
    1073758209U,	// ADD_RND20
    1082130433U,	// ADDimm7
    1073741825U,	// ADDpp
    1082130433U,	// ADDpp_imm7
    1627389953U,	// ADJCALLSTACKDOWN
    1635778561U,	// ADJCALLSTACKUP
    1107296257U,	// ALIGN16
    1107296257U,	// ALIGN24
    1115684865U,	// ALIGN8
    1074003969U,	// AND
    1124073489U,	// BITCLR
    1124073497U,	// BITSET
    1124073505U,	// BITTGL
    2197815337U,	// BITTST
    1132462134U,	// CALLa
    1140850748U,	// CALLp
    1132462147U,	// CLI
    536870984U,	// CSYNC
    536870991U,	// DISALGNEXCPT
    536871006U,	// EMUEXCPT
    1132462184U,	// EXCPT
    536871023U,	// IDLE
    1132462197U,	// JUMPa
    1149239419U,	// JUMPcc
    1140850815U,	// JUMPp
    1132462214U,	// LINK
    1695023105U,	// LOAD16fi
    1074528257U,	// LOAD16i
    1074528257U,	// LOAD16i_d16
    1167097857U,	// LOAD16pi
    1167376385U,	// LOAD16s32p_dec
    1167392769U,	// LOAD16s32p_inc
    1167409153U,	// LOAD16s32p_post
    1167425537U,	// LOAD16z32p_dec
    1167441921U,	// LOAD16z32p_inc
    1167413249U,	// LOAD16z32p_post
    1695023105U,	// LOAD32fi
    1175584769U,	// LOAD32fp_nimm7m4
    1175486465U,	// LOAD32i
    1175863297U,	// LOAD32i_dec
    1175879681U,	// LOAD32i_inc
    1175896065U,	// LOAD32i_post
    1182793729U,	// LOAD32imm
    1175486465U,	// LOAD32p
    1167261697U,	// LOAD32p_16s
    1191182337U,	// LOAD32p_16z
    1200816129U,	// LOAD32p_8s
    1207959553U,	// LOAD32p_8z
    1175863297U,	// LOAD32p_dec
    1200832513U,	// LOAD32p_imm16_8s
    1200836609U,	// LOAD32p_imm16_8z
    1167278081U,	// LOAD32p_imm17m2_16s
    1167282177U,	// LOAD32p_imm17m2_16z
    1175674881U,	// LOAD32p_imm18m4
    1175879681U,	// LOAD32p_inc
    1175896065U,	// LOAD32p_post
    1167278081U,	// LOAD32p_uimm5m2_16s
    1167282177U,	// LOAD32p_uimm5m2_16z
    1175674881U,	// LOAD32p_uimm6m4
    1216348161U,	// LOAD32sym
    1696071681U,	// LOAD8fi
    1200930817U,	// LOAD8s32p_dec
    1200947201U,	// LOAD8s32p_inc
    1200979969U,	// LOAD8z32p_dec
    1200996353U,	// LOAD8z32p_inc
    1167474689U,	// LOADhi_dec
    1167491073U,	// LOADhi_inc
    1167507457U,	// LOADhp_post
    1075576833U,	// LOADimm16
    1075576833U,	// LOADimm7
    1075838977U,	// LOADuimm16
    536871052U,	// MNOP
    1074528257U,	// MOVE
    2206204050U,	// MOVECC_nz
    1074528257U,	// MOVECC_zext
    1224736769U,	// MOVENCC_z
    536871064U,	// MOVE_cc_ac0
    536871074U,	// MOVE_ccncc
    536871074U,	// MOVE_ncccc
    2684354683U,	// MOVEcc
    1075576833U,	// MOVEsext
    1076101121U,	// MOVEsext8
    1075838977U,	// MOVEzext
    1076363265U,	// MOVEzext8
    1076854785U,	// MUL16
    1233125377U,	// MUL32
    1076871169U,	// MULHS16
    1076854785U,	// MULhh32s
    1076854785U,	// MULhh32u
    2197815468U,	// NBITTST
    1241513985U,	// NEG
    536871098U,	// NOP
    1249902593U,	// NOT
    1258291201U,	// ONES
    1076887553U,	// OR
    536871103U,	// OR_ac0_cc
    1266679809U,	// POP
    1132462282U,	// PUSH
    1132462292U,	// RAISE
    536871131U,	// RTS
    2348810386U,	// SETEQdd
    2348810386U,	// SETEQpp
    2348810386U,	// SETEQri
    2348810386U,	// SETEQri_not
    2357985426U,	// SETLEdd
    2357985426U,	// SETLEpp
    2357985426U,	// SETLEri
    2357985426U,	// SETLEri_not
    2366374034U,	// SETLTdd
    2366374034U,	// SETLTpp
    2366374034U,	// SETLTri
    2366374034U,	// SETLTri_not
    2348810386U,	// SETNEdd
    2360606866U,	// SETULEdd
    2360606866U,	// SETULEpp
    2360606866U,	// SETULEri
    2360606866U,	// SETULEri_not
    2368995474U,	// SETULTdd
    2368995474U,	// SETULTpp
    2368995474U,	// SETULTri
    2368995474U,	// SETULTri_not
    1303904257U,	// SLA16r
    1304166401U,	// SLAr16
    1077936129U,	// SLL16i
    1308622849U,	// SLL16r
    1317011457U,	// SLLi
    1317011457U,	// SLLr
    1308622849U,	// SLLr16
    1078198273U,	// SRA16i
    1325400065U,	// SRAi
    1325400065U,	// SRAr
    1078460417U,	// SRL16i
    1333788673U,	// SRLi
    1333788673U,	// SRLr
    536871136U,	// SSYNC
    1132462311U,	// STI
    1879048193U,	// STORE16fi
    3498049772U,	// STORE16i_dec
    3506438380U,	// STORE16i_inc
    3514826988U,	// STORE16p_post
    2449473772U,	// STORE16pi
    1879048193U,	// STORE32fi
    2457862383U,	// STORE32fp_nimm7m4
    2449473775U,	// STORE32i
    3498049775U,	// STORE32i_dec
    3506438383U,	// STORE32i_inc
    3514826991U,	// STORE32i_post
    2449473775U,	// STORE32p
    3498049775U,	// STORE32p_dec
    2466250991U,	// STORE32p_imm18m4
    3506438383U,	// STORE32p_inc
    3514826991U,	// STORE32p_post
    2466250991U,	// STORE32p_uimm6m4
    1937768449U,	// STORE8fi
    2449473777U,	// STORE8p
    3498049777U,	// STORE8p_dec
    2466250993U,	// STORE8p_imm16
    3506438385U,	// STORE8p_inc
    1078722561U,	// SUB
    1078722561U,	// SUB16
    536871156U,	// UNLINK
    1078984705U,	// XOR
    0U
  };

  const char *AsmStrs = 
    "\000\000PHINODE\000abort;\000bitclr(\000bitset(\000bittgl(\000cc = bitt"
    "st(\000call \000call (\000cli \000csync;\000disalignexcpt;\000emuexcpt;"
    "\000excpt \000idle;\000jump \000if \000JUMP (\000link \000mnop;\000cc ="
    " \000cc = ac0;\000cc = !cc;\000cc = !bittst(\000nop;\000ac0 |= cc;\000["
    "--sp] = \000raise \000rts;\000ssync;\000sti \000w[\000[\000b[\000unlink"
    ";\000";

  processDebugLoc(MI->getDebugLoc());


#ifndef NO_ASM_WRITER_BOILERPLATE
  if (MI->getOpcode() == TargetInstrInfo::INLINEASM) {
    O << "\t";
    printInlineAsm(MI);
    return;
  } else if (MI->isLabel()) {
    printLabel(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::DECLARE) {
    printDeclare(MI);
    return;
  } else if (MI->getOpcode() == TargetInstrInfo::IMPLICIT_DEF) {
    printImplicitDef(MI);
    return;
  }


#endif
  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 255);


  // Fragment 0 encoded into 3 bits for 7 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    return;
    break;
  case 1:
    // PHI, ABORT, CSYNC, DISALGNEXCPT, EMUEXCPT, IDLE, MNOP, MOVE_cc_ac0, MO...
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADD, ADD16, ADD_RND20, ADDimm7, ADDpp, ADDpp_imm7, ALIGN16, ALIGN24, A...
    printOperand(MI, 0); 
    break;
  case 3:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LOAD16fi, LOAD32fi, LOAD8fi, STORE16...
    PrintSpecial(MI, "comment"); 
    break;
  case 4:
    // BITTST, MOVECC_nz, NBITTST, SETEQdd, SETEQpp, SETEQri, SETEQri_not, SE...
    printOperand(MI, 1); 
    break;
  case 5:
    // MOVEcc
    printOperand(MI, 3); 
    O << ' '; 
    printOperand(MI, 0); 
    O << " = "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // STORE16i_dec, STORE16i_inc, STORE16p_post, STORE32i_dec, STORE32i_inc,...
    printOperand(MI, 2); 
    break;
  }


  // Fragment 1 encoded into 6 bits for 40 unique commands.
  switch ((Bits >> 23) & 63) {
  default:   // unreachable.
  case 0:
    // ADD, ADD16, ADD_RND20, ADDpp, AND, LOAD16i, LOAD16i_d16, LOADimm16, LO...
    O << " = "; 
    printOperand(MI, 1); 
    break;
  case 1:
    // ADDimm7, ADDpp_imm7
    O << " += "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // ADJCALLSTACKDOWN
    O << "ADJCALLSTACKDOWN "; 
    printOperand(MI, 0); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // ADJCALLSTACKUP
    O << "ADJCALLSTACKUP "; 
    printOperand(MI, 0); 
    O << ' '; 
    printOperand(MI, 1); 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // ALIGN16, ALIGN24
    O << " = align16("; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << ");"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // ALIGN8
    O << " = align8("; 
    printOperand(MI, 1); 
    O << ", "; 
    printOperand(MI, 2); 
    O << ");"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 6:
    // BITCLR, BITSET, BITTGL, BITTST, NBITTST
    O << ", "; 
    printOperand(MI, 2); 
    O << ");"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // CALLa, CLI, EXCPT, JUMPa, LINK, MOVECC_nz, PUSH, RAISE, STI
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // CALLp, JUMPp
    O << ");"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // JUMPcc
    O << " jump "; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // LOAD16fi, LOAD32fi, LOAD8fi
    O << "FI "; 
    printOperand(MI, 0); 
    break;
  case 11:
    // LOAD16pi, LOAD16s32p_dec, LOAD16s32p_inc, LOAD16s32p_post, LOAD16z32p_...
    O << " = w["; 
    break;
  case 12:
    // LOAD32fp_nimm7m4, LOAD32i, LOAD32i_dec, LOAD32i_inc, LOAD32i_post, LOA...
    O << " = ["; 
    break;
  case 13:
    // LOAD32imm
    O << ".h = ("; 
    printOperand(MI, 1); 
    O << " >> 16); "; 
    printOperand(MI, 0); 
    O << ".l = ("; 
    printOperand(MI, 1); 
    O << " & 0xffff);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 14:
    // LOAD32p_16z
    O << " = W["; 
    printOperand(MI, 1); 
    O << "] (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 15:
    // LOAD32p_8s, LOAD32p_imm16_8s, LOAD32p_imm16_8z, LOAD8s32p_dec, LOAD8s3...
    O << " = b["; 
    break;
  case 16:
    // LOAD32p_8z
    O << " = B["; 
    printOperand(MI, 1); 
    O << "] (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 17:
    // LOAD32sym
    O << ".h = "; 
    printOperand(MI, 1); 
    O << "; "; 
    printOperand(MI, 0); 
    O << ".l = "; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 18:
    // MOVENCC_z
    O << " = cc;"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 19:
    // MUL32
    O << " *= "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 20:
    // NEG
    O << " = -"; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 21:
    // NOT
    O << " = ~"; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 22:
    // ONES
    O << " = ones "; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 23:
    // POP
    O << " = [sp++];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 24:
    // SETEQdd, SETEQpp, SETEQri, SETEQri_not, SETNEdd
    O << " == "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 25:
    // SETLEdd, SETLEpp, SETLEri, SETLEri_not, SETULEdd, SETULEpp, SETULEri, ...
    O << " <= "; 
    printOperand(MI, 2); 
    break;
  case 26:
    // SETLTdd, SETLTpp, SETLTri, SETLTri_not, SETULTdd, SETULTpp, SETULTri, ...
    O << " < "; 
    printOperand(MI, 2); 
    break;
  case 27:
    // SLA16r, SLAr16
    O << " = ashift "; 
    printOperand(MI, 1); 
    break;
  case 28:
    // SLL16r, SLLr16
    O << " = lshift "; 
    printOperand(MI, 1); 
    O << " by "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 29:
    // SLLi, SLLr
    O << " <<= "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 30:
    // SRAi, SRAr
    O << " >>>= "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 31:
    // SRLi, SRLr
    O << " >>= "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 32:
    // STORE16fi, STORE32fi
    O << "FI ["; 
    printMemoryOperand(MI, 1); 
    O << "] = "; 
    printOperand(MI, 0); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 33:
    // STORE16i_dec, STORE32i_dec, STORE32p_dec, STORE8p_dec
    O << "--] = "; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 34:
    // STORE16i_inc, STORE32i_inc, STORE32p_inc, STORE8p_inc
    O << "++] = "; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 35:
    // STORE16p_post, STORE32i_post, STORE32p_post
    O << " ++ "; 
    printOperand(MI, 3); 
    O << "] = "; 
    printOperand(MI, 1); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 36:
    // STORE16pi, STORE32i, STORE32p, STORE8p
    O << "] = "; 
    printOperand(MI, 0); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 37:
    // STORE32fp_nimm7m4
    O << " - "; 
    printOperand(MI, 2); 
    O << "] = "; 
    printOperand(MI, 0); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 38:
    // STORE32p_imm18m4, STORE32p_uimm6m4, STORE8p_imm16
    O << " + "; 
    printOperand(MI, 2); 
    O << "] = "; 
    printOperand(MI, 0); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 39:
    // STORE8fi
    O << "FI b["; 
    printMemoryOperand(MI, 1); 
    O << "] = "; 
    printOperand(MI, 0); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 2 encoded into 5 bits for 21 unique commands.
  switch ((Bits >> 18) & 31) {
  default:   // unreachable.
  case 0:
    // ADD, ADD16, ADD_RND20, ADDpp
    O << " + "; 
    printOperand(MI, 2); 
    break;
  case 1:
    // AND
    O << " & "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // LOAD16fi, LOAD32fi
    O << " = ["; 
    printMemoryOperand(MI, 1); 
    O << "];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // LOAD16i, LOAD16i_d16, MOVE, MOVECC_zext, SETLEdd, SETLEpp, SETLEri, SE...
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // LOAD16pi, LOAD32fp_nimm7m4, LOAD32i, LOAD32p, LOAD32p_16s, LOAD32p_8s,...
    printOperand(MI, 1); 
    break;
  case 5:
    // LOAD16s32p_dec, LOAD16s32p_inc, LOAD16s32p_post, LOAD16z32p_dec, LOAD1...
    printOperand(MI, 2); 
    break;
  case 6:
    // LOAD8fi
    O << " = B["; 
    printMemoryOperand(MI, 1); 
    O << "];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // LOADimm16, LOADimm7, MOVEsext
    O << " (x);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // LOADuimm16, MOVEzext
    O << " (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // MOVEsext8
    O << ".b (x);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // MOVEzext8
    O << ".b (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 11:
    // MUL16, MULHS16, MULhh32s, MULhh32u
    O << " * "; 
    printOperand(MI, 2); 
    break;
  case 12:
    // OR
    O << " | "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 13:
    // SETULEdd, SETULEpp, SETULEri, SETULEri_not, SETULTdd, SETULTpp, SETULT...
    O << " (iu);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 14:
    // SLA16r
    O << " BY "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 15:
    // SLAr16
    O << " by "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 16:
    // SLL16i
    O << " << "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 17:
    // SRA16i
    O << " >>> "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 18:
    // SRL16i
    O << " >> "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 19:
    // SUB, SUB16
    O << " - "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 20:
    // XOR
    O << " ^ "; 
    printOperand(MI, 2); 
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 3 encoded into 4 bits for 16 unique commands.
  switch ((Bits >> 14) & 15) {
  default:   // unreachable.
  case 0:
    // ADD, ADD16, ADDpp
    O << ';'; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // ADD_RND20
    O << " (rnd20);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // LOAD16pi, LOAD32i, LOAD32p
    O << "];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 3:
    // LOAD16s32p_dec, LOAD8s32p_dec
    O << "--] (x);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 4:
    // LOAD16s32p_inc, LOAD8s32p_inc
    O << "++] (x);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 5:
    // LOAD16s32p_post, LOAD16z32p_post
    O << "++"; 
    printOperand(MI, 3); 
    break;
  case 6:
    // LOAD16z32p_dec, LOAD8z32p_dec
    O << "--] (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 7:
    // LOAD16z32p_inc, LOAD8z32p_inc
    O << "++] (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 8:
    // LOAD32fp_nimm7m4
    O << " - "; 
    printOperand(MI, 2); 
    O << "];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 9:
    // LOAD32i_dec, LOAD32p_dec, LOADhi_dec
    O << "--];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 10:
    // LOAD32i_inc, LOAD32p_inc, LOADhi_inc
    O << "++];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 11:
    // LOAD32i_post, LOAD32p_post, LOADhp_post
    O << " ++ "; 
    printOperand(MI, 3); 
    O << "];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 12:
    // LOAD32p_16s, LOAD32p_8s
    O << "] (x);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 13:
    // LOAD32p_imm16_8s, LOAD32p_imm16_8z, LOAD32p_imm17m2_16s, LOAD32p_imm17...
    O << " + "; 
    printOperand(MI, 2); 
    break;
  case 14:
    // MUL16, MULhh32s, MULhh32u
    O << " (is);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 15:
    // MULHS16
    O << " (ih);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }


  // Fragment 4 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 12) & 3) {
  default:   // unreachable.
  case 0:
    // LOAD16s32p_post, LOAD32p_imm16_8s, LOAD32p_imm17m2_16s, LOAD32p_uimm5m...
    O << "] (x);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 1:
    // LOAD16z32p_post, LOAD32p_imm16_8z, LOAD32p_imm17m2_16z, LOAD32p_uimm5m...
    O << "] (z);"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  case 2:
    // LOAD32p_imm18m4, LOAD32p_uimm6m4
    O << "];"; 
    EmitComments(*MI);

    O << "\n"; 
    return;
    break;
  }

  return;
}
